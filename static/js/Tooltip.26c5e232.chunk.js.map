{"version":3,"file":"static/js/Tooltip.26c5e232.chunk.js","mappings":"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","sources":["../node_modules/@fluentui/react/lib/components/src/components/Tooltip/Tooltip.types.ts","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/Tooltip.base.tsx","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/Tooltip.tsx","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/Tooltip.styles.ts","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/TooltipHost.types.ts","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/TooltipHost.base.tsx","../node_modules/@fluentui/utilities/src/overflow.ts","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/TooltipHost.styles.ts","../node_modules/@fluentui/react/lib/components/src/components/Tooltip/TooltipHost.ts"],"sourcesContent":["import * as React from 'react';\nimport { TooltipBase } from './Tooltip.base';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { ICalloutProps } from '../../Callout';\nimport type { IRenderFunction, IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IStyle, ITheme } from '../../Styling';\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltip {}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipProps extends React.HTMLAttributes<HTMLDivElement | TooltipBase> {\n  /**\n   * Optional callback to access the ITooltip interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<ITooltip>;\n\n  /**\n   * Properties to pass through for Callout.\n   * @defaultvalue `{ isBeakVisible: true, beakWidth: 16, gapSpace: 0, setInitialFocus: true, doNotLayer: false }`\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Content to be passed to the tooltip\n   */\n  content?: string | JSX.Element | JSX.Element[];\n\n  /**\n   * Render function to populate tooltip content.\n   */\n  onRenderContent?: IRenderFunction<ITooltipProps>;\n\n  /**\n   * Length of delay. Set to `TooltipDelay.zero` if you do not want a delay.\n   * @defaultvalue TooltipDelay.medium\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * Max width of tooltip\n   * @defaultvalue 364px\n   */\n  maxWidth?: string | null;\n\n  /**\n   * Element to anchor the Tooltip to.\n   */\n  targetElement?: HTMLElement;\n\n  /**\n   * How the tooltip should be anchored to its `targetElement`.\n   * @defaultvalue DirectionalHint.topCenter\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used instead\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<ITooltipStyleProps, ITooltipStyles>;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport enum TooltipDelay {\n  zero = 0,\n  /** 300 ms delay before showing the tooltip */\n  medium = 1,\n  /** 500 ms delay before showing the tooltip */\n  long = 2,\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipStyleProps {\n  theme: ITheme;\n\n  className?: string;\n\n  /**\n   * Delay before tooltip appears.\n   * @deprecated Delay logic moved to TooltipHost vs relying on animation delay.\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * Maximum width of tooltip.\n   */\n  maxWidth?: string;\n\n  /**\n   * The gap between the Callout and the target\n   * @defaultvalue 0\n   */\n  gapSpace?: number;\n\n  /**\n   * The width of the Callout's beak\n   * @defaultvalue 16\n   */\n  beakWidth?: number;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipStyles {\n  /**\n   * Style for the root element.\n   */\n  root: IStyle;\n\n  /**\n   * Style for the content element.\n   */\n  content: IStyle;\n\n  /**\n   * Style for the subtext element.\n   */\n  subText: IStyle;\n}\n","import * as React from 'react';\nimport { classNamesFunction, divProperties, getNativeProps } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type { ITooltipProps, ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nconst getClassNames = classNamesFunction<ITooltipStyleProps, ITooltipStyles>();\n\nexport class TooltipBase extends React.Component<ITooltipProps, any> {\n  // Specify default props values\n  public static defaultProps: Partial<ITooltipProps> = {\n    directionalHint: DirectionalHint.topCenter,\n    maxWidth: '364px',\n    calloutProps: {\n      isBeakVisible: true,\n      beakWidth: 16,\n      gapSpace: 0,\n      setInitialFocus: true,\n      doNotLayer: false,\n    },\n  };\n\n  private _classNames: IProcessedStyleSet<ITooltipStyles>;\n\n  public render(): JSX.Element {\n    const {\n      className,\n      calloutProps,\n      directionalHint,\n      directionalHintForRTL,\n      styles,\n      id,\n      maxWidth,\n      onRenderContent = this._onRenderContent,\n      targetElement,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className: className || (calloutProps && calloutProps.className),\n      beakWidth: calloutProps && calloutProps.beakWidth,\n      gapSpace: calloutProps && calloutProps.gapSpace,\n      maxWidth: maxWidth!,\n    });\n\n    return (\n      <Callout\n        target={targetElement}\n        directionalHint={directionalHint}\n        directionalHintForRTL={directionalHintForRTL}\n        {...calloutProps}\n        {...getNativeProps(this.props, divProperties, ['id'])} // omitting ID due to it being used in the div below\n        className={this._classNames.root}\n      >\n        <div\n          className={this._classNames.content}\n          id={id}\n          onMouseEnter={this.props.onMouseEnter}\n          onMouseLeave={this.props.onMouseLeave}\n        >\n          {onRenderContent(this.props, this._onRenderContent)}\n        </div>\n      </Callout>\n    );\n  }\n\n  private _onRenderContent = (props: ITooltipProps): JSX.Element => {\n    if (typeof props.content === 'string') {\n      return <p className={this._classNames.subText}>{props.content}</p>;\n    } else {\n      return <div className={this._classNames.subText}>{props.content}</div>;\n    }\n  };\n}\n","import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { TooltipBase } from './Tooltip.base';\nimport { getStyles } from './Tooltip.styles';\nimport type { ITooltipProps, ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nexport const Tooltip: React.FunctionComponent<ITooltipProps> = styled<\n  ITooltipProps,\n  ITooltipStyleProps,\n  ITooltipStyles\n>(TooltipBase, getStyles, undefined, {\n  scope: 'Tooltip',\n});\n","import { AnimationClassNames } from '../../Styling';\nimport type { ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nexport const getStyles = (props: ITooltipStyleProps): ITooltipStyles => {\n  const { className, beakWidth = 16, gapSpace = 0, maxWidth, theme } = props;\n  const { semanticColors, fonts, effects } = theme;\n\n  // The math here is done to account for the 45 degree rotation of the beak\n  // and sub-pixel rounding that differs across browsers, which is more noticeable when\n  // the device pixel ratio is larger\n  const tooltipGapSpace = -(Math.sqrt((beakWidth * beakWidth) / 2) + gapSpace) + 1 / window.devicePixelRatio;\n\n  return {\n    root: [\n      'ms-Tooltip',\n      theme.fonts.medium,\n      AnimationClassNames.fadeIn200,\n      {\n        background: semanticColors.menuBackground,\n        boxShadow: effects.elevation8,\n        padding: '8px',\n        maxWidth: maxWidth,\n        selectors: {\n          ':after': {\n            content: `''`,\n            position: 'absolute',\n            bottom: tooltipGapSpace,\n            left: tooltipGapSpace,\n            right: tooltipGapSpace,\n            top: tooltipGapSpace,\n            zIndex: 0,\n          },\n        },\n      },\n      className,\n    ],\n    content: [\n      'ms-Tooltip-content',\n      fonts.small,\n      {\n        position: 'relative',\n        zIndex: 1,\n        color: semanticColors.menuItemText,\n        wordWrap: 'break-word',\n        overflowWrap: 'break-word',\n        overflow: 'hidden',\n      },\n    ],\n    subText: [\n      'ms-Tooltip-subtext',\n      {\n        // Using inherit here to avoid unintentional global overrides of the <p> tag.\n        fontSize: 'inherit',\n        fontWeight: 'inherit',\n        color: 'inherit',\n        margin: 0,\n      },\n    ],\n  };\n};\n","import * as React from 'react';\nimport { TooltipHostBase } from './TooltipHost.base';\nimport { TooltipDelay } from './Tooltip.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { ITooltipProps } from './Tooltip.types';\nimport type { ICalloutProps } from '../../Callout';\nimport type { IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IStyle, ITheme } from '../../Styling';\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHost {\n  /**\n   * Shows the tooltip.\n   */\n  show: () => void;\n\n  /**\n   * Dismisses the tooltip.\n   */\n  dismiss: () => void;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport enum TooltipOverflowMode {\n  /** Only show tooltip if parent DOM element is overflowing */\n  Parent,\n\n  /**\n   * Only show tooltip if tooltip host's content is overflowing.\n   * Note that this does not check the children for overflow, only the TooltipHost root.\n   */\n  Self,\n}\n\n/**\n * TooltipHost props. Note that native props (such as `id`, `className`, and `aria-` props) are\n * passed through to the Tooltip itself, rather than being used on the host element.\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostProps extends React.HTMLAttributes<HTMLDivElement | TooltipHostBase> {\n  /**\n   * Optional callback to access the ITooltipHost interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<ITooltipHost>;\n\n  /**\n   * Additional properties to pass through for Callout.\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Number of milliseconds to delay closing the tooltip, so that the user has time to hover over\n   * the tooltip and interact with it. Hovering over the tooltip will count as hovering over the\n   * host, so that the tooltip will stay open if the user is actively interacting with it.\n   */\n  closeDelay?: number;\n\n  /**\n   * Content to display in the Tooltip.\n   */\n  content?: string | JSX.Element | JSX.Element[];\n\n  /**\n   * Length of delay before showing the tooltip on hover.\n   * @defaultvalue TooltipDelay.medium\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * How the tooltip should be anchored to its `targetElement`.\n   * @defaultvalue DirectionalHint.topCenter\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used.\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * Class name to apply to tooltip host.\n   */\n  hostClassName?: string;\n\n  /**\n   * Class name to apply to the *tooltip itself*, not the host.\n   * To apply a class to the host, use `hostClassName` or `styles.root`.\n   */\n  className?: string;\n\n  /**\n   * If this is unset (the default), the tooltip is always shown even if there's no overflow.\n   *\n   * If set, only show the tooltip if the specified element (`Self` or `Parent`) has overflow.\n   * When set to `Parent`, the parent element is also used as the tooltip's target element.\n   *\n   * Note that even with `Self` mode, the TooltipHost *does not* check whether any children have overflow.\n   */\n  overflowMode?: TooltipOverflowMode;\n\n  /**\n   * Whether or not to mark the TooltipHost root element as described by the tooltip.\n   * Since this applies aria-describedby to a generic <div>, the description will not be\n   * read by screen readers. Instead, the caller should pass an `id` to the TooltipHost\n   * (to be passed through to the Tooltip) and mark the appropriate element as `aria-describedby`\n   * with the `id`.\n   * @defaultvalue true\n   * @deprecated use aria-describedby on the appropriate element instead\n   */\n  setAriaDescribedBy?: boolean;\n\n  /**\n   * Additional properties to pass through for Tooltip.\n   */\n  tooltipProps?: ITooltipProps;\n\n  /**\n   * Optional ID to pass through to the tooltip (not used on the host itself).\n   * Auto-generated if not provided.\n   */\n  id?: string;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<ITooltipHostStyleProps, ITooltipHostStyles>;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Notifies when tooltip becomes visible or hidden, whatever the trigger was.\n   */\n  onTooltipToggle?(isTooltipVisible: boolean): void;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostStyleProps {\n  theme: ITheme;\n  className?: string;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostStyles {\n  /**\n   * Style for the host wrapper element.\n   */\n  root: IStyle;\n}\n","import * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport {\n  initializeComponentRef,\n  Async,\n  divProperties,\n  getNativeProps,\n  getId,\n  assign,\n  hasOverflow,\n  portalContainsElement,\n  classNamesFunction,\n  KeyCodes,\n} from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nimport type { ITooltipHostProps, ITooltipHostStyles, ITooltipHostStyleProps, ITooltipHost } from './TooltipHost.types';\n\nexport interface ITooltipHostState {\n  isAriaPlaceholderRendered: boolean;\n  isTooltipVisible: boolean;\n}\n\nconst getClassNames = classNamesFunction<ITooltipHostStyleProps, ITooltipHostStyles>();\n\nexport class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {\n  public static defaultProps = {\n    delay: TooltipDelay.medium,\n  };\n\n  private static _currentVisibleTooltip: ITooltipHost | undefined;\n\n  // The wrapping div that gets the hover events\n  private _tooltipHost = React.createRef<HTMLDivElement>();\n\n  private _classNames: { [key in keyof ITooltipHostStyles]: string };\n  private _async: Async;\n  private _dismissTimerId: number;\n  private _openTimerId: number;\n  private _defaultTooltipId = getId('tooltip');\n  private _ignoreNextFocusEvent: boolean;\n\n  // Constructor\n  constructor(props: ITooltipHostProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false,\n    };\n\n    this._async = new Async(this);\n  }\n\n  // Render\n  public render(): JSX.Element {\n    const {\n      calloutProps,\n      children,\n      content,\n      directionalHint,\n      directionalHintForRTL,\n      hostClassName: className,\n      id,\n      // eslint-disable-next-line deprecation/deprecation\n      setAriaDescribedBy = true,\n      tooltipProps,\n      styles,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    const { isAriaPlaceholderRendered, isTooltipVisible } = this.state;\n    const tooltipId = id || this._defaultTooltipId;\n    const isContentPresent = !!(\n      content ||\n      (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent())\n    );\n    const showTooltip = isTooltipVisible && isContentPresent;\n    const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n\n    return (\n      <div\n        className={this._classNames.root}\n        ref={this._tooltipHost}\n        {...{ onFocusCapture: this._onTooltipFocus }}\n        {...{ onBlurCapture: this._onTooltipBlur }}\n        onMouseEnter={this._onTooltipMouseEnter}\n        onMouseLeave={this._onTooltipMouseLeave}\n        onKeyDown={this._onTooltipKeyDown}\n        role=\"none\"\n        // WARNING: aria-describedby on this node provides no value, since it isn't allowed generic elements\n        aria-describedby={ariaDescribedBy}\n      >\n        {children}\n        {showTooltip && (\n          <Tooltip\n            id={tooltipId}\n            content={content}\n            targetElement={this._getTargetElement()}\n            directionalHint={directionalHint}\n            directionalHintForRTL={directionalHintForRTL}\n            calloutProps={assign({}, calloutProps, {\n              onDismiss: this._hideTooltip,\n              onMouseEnter: this._onTooltipMouseEnter,\n              onMouseLeave: this._onTooltipMouseLeave,\n            })}\n            onMouseEnter={this._onTooltipMouseEnter}\n            onMouseLeave={this._onTooltipMouseLeave}\n            {...getNativeProps(this.props, divProperties)}\n            {...tooltipProps}\n          />\n        )}\n        {isAriaPlaceholderRendered && (\n          <div id={tooltipId} role=\"none\" style={hiddenContentStyle as React.CSSProperties}>\n            {content}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  }\n\n  public show = (): void => {\n    this._toggleTooltip(true);\n  };\n\n  public dismiss = (): void => {\n    this._hideTooltip();\n  };\n\n  private _getTargetElement = (): HTMLElement | undefined => {\n    if (!this._tooltipHost.current) {\n      return undefined;\n    }\n\n    const { overflowMode } = this.props;\n\n    // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n    // to the parent element, otherwise it might look off.\n    if (overflowMode !== undefined) {\n      switch (overflowMode) {\n        case TooltipOverflowMode.Parent:\n          return this._tooltipHost.current.parentElement!;\n\n        case TooltipOverflowMode.Self:\n          return this._tooltipHost.current;\n      }\n    }\n\n    return this._tooltipHost.current;\n  };\n\n  private _onTooltipFocus = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this._ignoreNextFocusEvent) {\n      this._ignoreNextFocusEvent = false;\n      return;\n    }\n\n    this._onTooltipMouseEnter(ev);\n  };\n\n  private _onTooltipBlur = (ev: React.FocusEvent<HTMLElement>) => {\n    // The focused element gets a blur event when the document loses focus\n    // (e.g. switching tabs in the browser), but we don't want to show the\n    // tooltip again when the document gets focus back. Handle this case by\n    // checking if the blurred element is still the document's activeElement,\n    // and ignoring when it next gets focus back.\n    // See https://github.com/microsoft/fluentui/issues/13541\n    this._ignoreNextFocusEvent = document?.activeElement === ev.target;\n\n    this._hideTooltip();\n  };\n\n  // Show Tooltip\n  private _onTooltipMouseEnter = (ev: any): void => {\n    const { overflowMode, delay } = this.props;\n\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    if (overflowMode !== undefined) {\n      const overflowElement = this._getTargetElement();\n      if (overflowElement && !hasOverflow(overflowElement)) {\n        return;\n      }\n    }\n\n    if (ev.target && portalContainsElement(ev.target as HTMLElement, this._getTargetElement())) {\n      // Do not show tooltip when target is inside a portal relative to TooltipHost.\n      return;\n    }\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (delay !== TooltipDelay.zero) {\n      this.setState({ isAriaPlaceholderRendered: true });\n      const delayTime = this._getDelayTime(delay!); // non-null assertion because we set it in `defaultProps`\n\n      this._openTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(true);\n      }, delayTime);\n    } else {\n      this._toggleTooltip(true);\n    }\n  };\n\n  // Hide Tooltip\n  private _onTooltipMouseLeave = (ev: any): void => {\n    const { closeDelay } = this.props;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (closeDelay) {\n      this._dismissTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(false);\n      }, closeDelay);\n    } else {\n      this._toggleTooltip(false);\n    }\n\n    if (TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n  };\n\n  private _onTooltipKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    if ((ev.which === KeyCodes.escape || ev.ctrlKey) && this.state.isTooltipVisible) {\n      this._hideTooltip();\n      ev.stopPropagation();\n    }\n  };\n\n  private _clearDismissTimer = (): void => {\n    this._async.clearTimeout(this._dismissTimerId);\n  };\n\n  private _clearOpenTimer = (): void => {\n    this._async.clearTimeout(this._openTimerId);\n  };\n\n  // Hide Tooltip\n  private _hideTooltip = (): void => {\n    this._clearOpenTimer();\n    this._clearDismissTimer();\n    this._toggleTooltip(false);\n  };\n\n  private _toggleTooltip = (isTooltipVisible: boolean): void => {\n    if (this.state.isTooltipVisible !== isTooltipVisible) {\n      this.setState(\n        { isAriaPlaceholderRendered: false, isTooltipVisible },\n        () => this.props.onTooltipToggle && this.props.onTooltipToggle(isTooltipVisible),\n      );\n    }\n  };\n\n  private _getDelayTime = (delay: TooltipDelay): number => {\n    switch (delay) {\n      case TooltipDelay.medium:\n        return 300;\n      case TooltipDelay.long:\n        return 500;\n      default:\n        return 0;\n    }\n  };\n}\n","/**\n * Detects whether an element's content has horizontal overflow\n *\n * @public\n * @param element - Element to check for overflow\n * @returns True if element's content overflows\n */\nexport function hasHorizontalOverflow(element: HTMLElement): boolean {\n  return element.clientWidth < element.scrollWidth;\n}\n\n/**\n * Detects whether an element's content has vertical overflow\n *\n * @public\n * @param element - Element to check for overflow\n * @returns True if element's content overflows\n */\nexport function hasVerticalOverflow(element: HTMLElement): boolean {\n  return element.clientHeight < element.scrollHeight;\n}\n\n/**\n * Detects whether an element's content has overflow in any direction\n *\n * @public\n * @param element - Element to check for overflow\n * @returns True if element's content overflows\n */\nexport function hasOverflow(element: HTMLElement): boolean {\n  return hasHorizontalOverflow(element) || hasVerticalOverflow(element);\n}\n","import { getGlobalClassNames } from '../../Styling';\nimport type { ITooltipHostStyleProps, ITooltipHostStyles } from './TooltipHost.types';\n\nconst GlobalClassNames = {\n  root: 'ms-TooltipHost',\n  ariaPlaceholder: 'ms-TooltipHost-aria-placeholder',\n};\n\nexport const getStyles = (props: ITooltipHostStyleProps): ITooltipHostStyles => {\n  const { className, theme } = props;\n  const classNames = getGlobalClassNames(GlobalClassNames, theme);\n\n  return {\n    root: [\n      classNames.root,\n      {\n        display: 'inline',\n      },\n      className,\n    ],\n  };\n};\n","import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { TooltipHostBase } from './TooltipHost.base';\nimport { getStyles } from './TooltipHost.styles';\nimport type { ITooltipHostProps, ITooltipHostStyleProps, ITooltipHostStyles } from './TooltipHost.types';\n\nexport const TooltipHost: React.FunctionComponent<ITooltipHostProps> = styled<\n  ITooltipHostProps,\n  ITooltipHostStyleProps,\n  ITooltipHostStyles\n>(TooltipHostBase, getStyles, undefined, {\n  scope: 'TooltipHost',\n});\n"],"names":["TooltipDelay","getClassNames","classNamesFunction","_onRenderContent","props","content","className","_classNames","subText","render","this","calloutProps","directionalHint","directionalHintForRTL","styles","id","maxWidth","onRenderContent","targetElement","theme","beakWidth","gapSpace","Callout","target","root","onMouseEnter","onMouseLeave","defaultProps","DirectionalHint","isBeakVisible","setInitialFocus","doNotLayer","Tooltip","styled","TooltipBase","semanticColors","fonts","effects","tooltipGapSpace","Math","sqrt","window","devicePixelRatio","medium","background","menuBackground","boxShadow","elevation8","padding","selectors","position","bottom","left","right","top","zIndex","small","color","menuItemText","wordWrap","overflowWrap","overflow","fontSize","fontWeight","margin","undefined","scope","TooltipOverflowMode","_tooltipHost","_defaultTooltipId","getId","show","_toggleTooltip","dismiss","_hideTooltip","_getTargetElement","current","overflowMode","Parent","parentElement","Self","_onTooltipFocus","ev","_ignoreNextFocusEvent","_onTooltipMouseEnter","_onTooltipBlur","document","activeElement","element","delay","TooltipHostBase","_currentVisibleTooltip","overflowElement","clientWidth","scrollWidth","hasHorizontalOverflow","clientHeight","scrollHeight","hasVerticalOverflow","portalContainsElement","_clearDismissTimer","_clearOpenTimer","zero","setState","isAriaPlaceholderRendered","delayTime","_getDelayTime","_openTimerId","_async","setTimeout","_onTooltipMouseLeave","closeDelay","_dismissTimerId","_onTooltipKeyDown","which","KeyCodes","ctrlKey","state","isTooltipVisible","stopPropagation","clearTimeout","onTooltipToggle","long","initializeComponentRef","Async","children","setAriaDescribedBy","tooltipProps","tooltipId","isContentPresent","showTooltip","ariaDescribedBy","ref","onFocusCapture","onBlurCapture","onKeyDown","role","onDismiss","style","componentWillUnmount","dispose","GlobalClassNames","ariaPlaceholder","TooltipHost","display"],"sourceRoot":""}