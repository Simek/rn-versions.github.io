{"version":3,"sources":["generateColor.ts","HistoryReader.ts","VersionDownloadChart.tsx"],"names":["cssColorFromHsv","hue","sat","val","l","s","Math","round","hueDifference","hue1","hue2","abs","HistoryReader","packageIdentifier","packageDescription","datePointsSorted","majorDatePoints","patchDatePoints","prereleaseDatePoints","historyFile","require","this","packages","accumulateDatePoints","versionMapper","mapToMajor","version","versionParts","semver","parse","major","minor","extraFilter","point","prerelease","opts","points","filter","versionFilter","pointsByMappedVersion","mappedVersion","versionPoints","versionDatePoint","find","p","date","count","push","pointsByVersionByDate","sort","p1","p2","map","Object","entries","instances","VersionDownloadChart","identifier","maxVersionsShown","showLegend","showTooltip","measurementTransform","rawDatapoints","historyReader","get","getMajorDatePoints","getPatchDatePoints","getPrereleaseDataPoints","createDownloadHistoryPoints","topRawDataPoints","historyPoints","n","windowInDays","latestDate","max","earliestAllowableDate","versionsInWindow","existingCount","v","newCount","topVersions","a","b","slice","topVersionsInOrder","includes","filteredPoints","pointsByDate","Map","last","set","datesAscending","keys","pointsWithZero","topVersion","existingPoint","filterTopN","datapoints","totalCountByDate","prevTotal","transformToPercentage","dateTimeFormat","Intl","DateTimeFormat","allVersionsSet","Set","allVersionsArr","latAvoidToken","undefined","chartAreas","i","avoidToken","randomGenerator","randomSeed","create","triesRemaining","random","adjacentHue","allHues","otherHue","color","saturation","value","generateColor","styles","area","name","key","dataKey","datapoint","versionCounts","stackId","stroke","fill","data","measurePoint","datePoint","length","style","height","responsiveContainer","display","alignItems","justifyContent","flexDirection","FadeIn","duration","xAxis","type","interval","scale","domain","tickFormatter","unixTime","format","Date","yAxis","toLocaleString","grid","tooltip","labelFormatter","formatter","_rnVersion","entry","pct","values","payload","reduce","legend"],"mappings":"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","file":"static/js/4.4a4e6bf3.chunk.js","sourcesContent":["import randomSeed from \"random-seed\";\n\nexport type AvoidToken = {\n  adjacentHue: number;\n  allHues: number[];\n};\n\n/**\n * Generates a color with random distribution, stable for a given semver\n * version. Allows passing an `avoidToken` generated by a previous color, to avoid a color similar\n * to it.\n *\n * * Derived from:\n * - http://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/\n * - https://github.com/devongovett/color-generator\n */\nexport default function generateColor(\n  version: string,\n  avoidToken?: AvoidToken\n): { color: string; avoidToken: AvoidToken } {\n  const adjacentHueThreshold = 0.25;\n  const allHueThreshold = 0.05;\n\n  const goldenRatio = 0.618033988749895;\n\n  const randomGenerator = randomSeed.create(version);\n  let hue: number;\n  let triesRemaining = 100;\n\n  do {\n    hue = randomGenerator.random();\n    hue += goldenRatio;\n    hue %= 1;\n  } while (\n    avoidToken &&\n    --triesRemaining > 0 &&\n    (hueDifference(hue, avoidToken.adjacentHue) < adjacentHueThreshold ||\n      avoidToken.allHues.find(\n        // eslint-disable-next-line no-loop-func\n        (otherHue) => hueDifference(hue, otherHue) < allHueThreshold\n      ))\n  );\n\n  const saturation = 0.9;\n  const value = 0.85;\n\n  const h = hue * 360;\n  const s = saturation * 100;\n  const v = value * 100;\n\n  return {\n    color: cssColorFromHsv(h, s, v),\n    avoidToken: {\n      adjacentHue: hue,\n      allHues: [...(avoidToken?.allHues ?? []), hue],\n    },\n  };\n}\n\nfunction cssColorFromHsv(hue: number, sat: number, val: number) {\n  const h = hue;\n  const l = ((2 - sat / 100) * val) / 2;\n  const s = (sat * val) / (l < 50 ? l * 2 : 200 - l * 2);\n\n  return `hsl(${h}, ${Math.round(s)}%, ${Math.round(l)}%)`;\n}\n\nfunction hueDifference(hue1: number, hue2: number) {\n  return Math.abs(((hue1 - hue2 + 0.5) % 1.0) - 0.5);\n}\n","import semver from \"semver\";\nimport {\n  PackageDescription,\n  PackageIdentifier,\n  packages,\n} from \"./PackageDescription\";\n\ntype HistoryFile = {\n  [packageName: string]: HistoryPoint[] | undefined;\n};\n\nexport type HistoryPoint = { date: number; version: string; count: number };\n\n/**\n * Allows reading from stored download history of an npm package\n */\nexport default class HistoryReader {\n  private readonly packageDescription: PackageDescription;\n  private readonly datePointsSorted: HistoryPoint[];\n\n  private majorDatePoints: HistoryPoint[] | null = null;\n  private patchDatePoints: HistoryPoint[] | null = null;\n  private prereleaseDatePoints: HistoryPoint[] | null = null;\n\n  private static instances: Partial<Record<PackageIdentifier, HistoryReader>> =\n    {};\n\n  private constructor(packageIdentifier: PackageIdentifier) {\n    const historyFile: HistoryFile = require(\"./assets/download_history.json\");\n    this.packageDescription = packages[packageIdentifier];\n    this.datePointsSorted = historyFile[packageIdentifier] ?? [];\n  }\n\n  static get(packageIdentifier: PackageIdentifier): HistoryReader {\n    if (!HistoryReader.instances[packageIdentifier]) {\n      HistoryReader.instances[packageIdentifier] = new HistoryReader(\n        packageIdentifier\n      );\n    }\n    return HistoryReader.instances[packageIdentifier]!;\n  }\n\n  getMajorDatePoints(): HistoryPoint[] {\n    if (!this.majorDatePoints) {\n      this.majorDatePoints = this.accumulateDatePoints({\n        versionMapper: this.mapToMajor,\n      });\n    }\n    return this.majorDatePoints;\n  }\n\n  private mapToMajor(version: string) {\n    const versionParts = semver.parse(version)!;\n\n    if (versionParts.major === 0) {\n      return `0.${versionParts.minor}`;\n    } else {\n      return `${versionParts.major}.0`;\n    }\n  }\n\n  getPatchDatePoints(): HistoryPoint[] {\n    if (!this.patchDatePoints) {\n      this.patchDatePoints = this.accumulateDatePoints();\n    }\n    return this.patchDatePoints;\n  }\n\n  getPrereleaseDataPoints(): HistoryPoint[] {\n    if (!this.prereleaseDatePoints) {\n      this.prereleaseDatePoints = this.accumulateDatePoints({\n        extraFilter: (point) => !!semver.prerelease(point.version),\n      });\n    }\n    return this.prereleaseDatePoints;\n  }\n\n  private accumulateDatePoints(opts?: {\n    versionMapper?: (v: string) => string;\n    extraFilter?: (point: HistoryPoint) => boolean;\n  }): HistoryPoint[] {\n    let points: HistoryPoint[];\n\n    if (opts?.extraFilter) {\n      points = this.datePointsSorted.filter(\n        (point) =>\n          opts.extraFilter!(point) &&\n          this.packageDescription.versionFilter(point.version)\n      );\n    } else {\n      points = this.datePointsSorted.filter((point) =>\n        this.packageDescription.versionFilter(point.version)\n      );\n    }\n\n    if (opts?.versionMapper) {\n      const pointsByMappedVersion: Record<\n        string,\n        Array<{ date: number; count: number }> | undefined\n      > = {};\n\n      for (const point of points) {\n        const mappedVersion = opts.versionMapper(point.version);\n\n        const versionPoints = pointsByMappedVersion[mappedVersion] ?? [];\n        pointsByMappedVersion[mappedVersion] = versionPoints;\n\n        const versionDatePoint = versionPoints.find(\n          (p) => point.date === p.date\n        );\n\n        if (versionDatePoint) {\n          versionDatePoint.count += point.count;\n        } else {\n          versionPoints.push({ date: point.date, count: point.count });\n        }\n      }\n\n      points = [];\n      for (const [version, pointsByVersion] of Object.entries(\n        pointsByMappedVersion\n      )) {\n        const pointsByVersionByDate = pointsByVersion!.sort(\n          (p1, p2) => p1.date - p2.date\n        );\n        points.push(...pointsByVersionByDate.map((p) => ({ ...p, version })));\n      }\n    }\n\n    return points;\n  }\n}\n","import React from \"react\";\n\nimport generateColor, { AvoidToken } from \"./generateColor\";\nimport styles from \"./VersionDownloadChart.styles\";\n\nimport {\n  AreaChart,\n  Area,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  ResponsiveContainer,\n  Legend,\n} from \"recharts\";\nimport HistoryReader, { HistoryPoint } from \"./HistoryReader\";\nimport { PackageIdentifier } from \"./PackageDescription\";\nimport FadeIn from \"./FadeIn\";\n\nexport type VersionFilter = \"major\" | \"patch\" | \"prerelease\";\n\nexport type MeasurementTransform = \"totalDownloads\" | \"percentage\";\n\nexport type VersionDownloadChartProps = {\n  /**\n   * Which package to show data for\n   */\n  identifier: PackageIdentifier;\n\n  /**\n   * Number of versions shown at once, with the most popular versions always\n   * showing up\n   */\n  maxVersionsShown?: number;\n\n  /**\n   * Whether to show the legend (defaults to true)\n   */\n  showLegend?: boolean;\n\n  /**\n   * Whether to show the tooltip (defaults to true)\n   */\n  showTooltip?: boolean;\n\n  /**\n   * Which versions to show in the graph. Defaults to only major versions\n   */\n  versionFilter?: VersionFilter;\n\n  /**\n   * Allows transforming raw measurements to a different unit\n   */\n  measurementTransform?: MeasurementTransform;\n};\n\nconst VersionDownloadChart: React.FC<VersionDownloadChartProps> = ({\n  identifier,\n  maxVersionsShown,\n  versionFilter,\n  showLegend,\n  showTooltip,\n  measurementTransform,\n}) => {\n  const rawDatapoints = createDownloadHistoryPoints(\n    identifier,\n    versionFilter || \"major\"\n  );\n\n  const topRawDataPoints = maxVersionsShown\n    ? filterTopN(rawDatapoints, maxVersionsShown, 20 /*windowInDays*/)\n    : rawDatapoints;\n\n  const datapoints =\n    measurementTransform === \"percentage\"\n      ? transformToPercentage(topRawDataPoints)\n      : topRawDataPoints;\n\n  const dateTimeFormat = new Intl.DateTimeFormat(\"en-US\");\n\n  const allVersionsSet = new Set(datapoints.map((p) => p.version));\n  const allVersionsArr = [...allVersionsSet];\n\n  let latAvoidToken: AvoidToken | undefined = undefined;\n  const chartAreas = allVersionsArr.map((v, i) => {\n    const { color, avoidToken } = generateColor(v, latAvoidToken);\n    latAvoidToken = avoidToken;\n\n    return (\n      <Area\n        {...styles.area}\n        name={v}\n        key={v}\n        dataKey={(datapoint) => datapoint.versionCounts[v]}\n        stackId=\"1\"\n        stroke={color}\n        fill={color}\n      />\n    );\n  });\n\n  const data: Array<{ date: number; versionCounts: Record<string, number> }> =\n    [];\n  for (const version of allVersionsArr) {\n    for (const measurePoint of datapoints) {\n      if (measurePoint.version === version) {\n        const datePoint = data.find((p) => p.date === measurePoint.date);\n        if (datePoint) {\n          datePoint.versionCounts[version] = measurePoint.count;\n        } else {\n          data.push({\n            date: measurePoint.date,\n            versionCounts: { [version]: measurePoint.count },\n          });\n        }\n      }\n    }\n  }\n\n  if (datapoints.length === 0) {\n    return (\n      <div\n        style={{\n          height: styles.responsiveContainer.height,\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          flexDirection: \"column\",\n        }}\n      >\n        <h4\n          style={{\n            color: \"#888\",\n          }}\n        >\n          No data available\n        </h4>\n      </div>\n    );\n  }\n\n  return (\n    <FadeIn duration=\"fast\">\n      <ResponsiveContainer {...styles.responsiveContainer}>\n        <AreaChart data={data}>\n          <XAxis\n            {...styles.xAxis}\n            dataKey=\"date\"\n            type=\"number\"\n            interval=\"preserveStartEnd\"\n            scale=\"time\"\n            domain={[\"dataMin\", \"dataMax\"]}\n            tickFormatter={(unixTime) =>\n              dateTimeFormat.format(new Date(unixTime))\n            }\n          />\n          <YAxis\n            {...styles.yAxis}\n            type=\"number\"\n            {...(measurementTransform === \"percentage\"\n              ? {\n                  domain: [0, 1],\n                  tickFormatter: (count) => `${Math.round(count * 100)}%`,\n                }\n              : {\n                  domain: [\"auto\", \"auto\"],\n                  tickFormatter: (count) => count.toLocaleString(),\n                })}\n          />\n          <CartesianGrid {...styles.grid} />\n\n          {showTooltip !== false && (\n            <Tooltip\n              {...styles.tooltip}\n              labelFormatter={(unixTime) =>\n                dateTimeFormat.format(new Date(unixTime))\n              }\n              formatter={(count, _rnVersion, entry) => {\n                const totalCount = (\n                  Object.values(entry.payload.versionCounts) as number[]\n                ).reduce((a, b) => a + b, 0);\n\n                const pct = ((count as number) / totalCount) * 100;\n\n                if (measurementTransform === \"percentage\") {\n                  return `${Math.round(pct * 100) / 100}%`;\n                } else {\n                  return `${count.toLocaleString()} (${Math.round(pct)}%)`;\n                }\n              }}\n            />\n          )}\n\n          {showLegend !== false && <Legend {...styles.legend} />}\n\n          {chartAreas}\n        </AreaChart>\n      </ResponsiveContainer>\n    </FadeIn>\n  );\n};\n\n/**\n * Create the point representation of downloads to show\n */\nfunction createDownloadHistoryPoints(\n  identifier: PackageIdentifier,\n  versionFilter: \"major\" | \"patch\" | \"prerelease\"\n): HistoryPoint[] {\n  const historyReader = HistoryReader.get(identifier);\n\n  switch (versionFilter) {\n    case \"major\":\n      return historyReader.getMajorDatePoints();\n    case \"patch\":\n      return historyReader.getPatchDatePoints();\n    case \"prerelease\":\n      return historyReader.getPrereleaseDataPoints();\n  }\n}\n\nfunction transformToPercentage(points: HistoryPoint[]): HistoryPoint[] {\n  const totalCountByDate: Record<number, number | undefined> = {};\n\n  for (const point of points) {\n    const prevTotal = totalCountByDate[point.date] ?? 0;\n    totalCountByDate[point.date] = prevTotal + point.count;\n  }\n\n  return points.map((point) => ({\n    ...point,\n    count: point.count / totalCountByDate[point.date]!,\n  }));\n}\n\nfunction filterTopN(\n  historyPoints: HistoryPoint[],\n  n: number,\n  windowInDays: number\n): HistoryPoint[] {\n  let latestDate: number = 0;\n  for (const point of historyPoints) {\n    latestDate = Math.max(latestDate, point.date);\n  }\n\n  const earliestAllowableDate = latestDate - windowInDays * 24 * 60 * 60 * 1000;\n  const versionsInWindow: Array<{ version: string; count: number }> = [];\n\n  for (const point of historyPoints) {\n    if (point.date >= earliestAllowableDate) {\n      const existingCount = versionsInWindow.find(\n        (v) => v.version === point.version\n      );\n      const newCount = point.date < earliestAllowableDate ? 0 : point.count;\n\n      if (existingCount) {\n        existingCount.count += newCount;\n      } else {\n        versionsInWindow.push({ version: point.version, count: newCount });\n      }\n    }\n  }\n\n  const topVersions = versionsInWindow\n    .sort((a, b) => a.count - b.count)\n    .slice(-n)\n    .map((v) => v.version);\n\n  const topVersionsInOrder: string[] = [];\n  for (const point of historyPoints) {\n    if (\n      topVersions.includes(point.version) &&\n      !topVersionsInOrder.includes(point.version)\n    ) {\n      topVersionsInOrder.push(point.version);\n    }\n  }\n\n  const filteredPoints: HistoryPoint[] = [];\n  for (const point of historyPoints) {\n    if (topVersions.includes(point.version)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  const pointsByDate: Map<\n    number,\n    { version: string; count: number }[] | undefined\n  > = new Map();\n  for (const point of filteredPoints) {\n    const last = pointsByDate.get(point.date) ?? [];\n    pointsByDate.set(point.date, [...last, point]);\n  }\n\n  const datesAscending = [...pointsByDate.keys()].sort();\n  const pointsWithZero: HistoryPoint[] = [];\n\n  for (const date of datesAscending) {\n    for (const topVersion of topVersionsInOrder) {\n      const existingPoint = pointsByDate\n        .get(date)!\n        .find((p) => p.version === topVersion);\n      if (existingPoint) {\n        pointsWithZero.push({ date, ...existingPoint });\n      } else {\n        pointsWithZero.push({ date, version: topVersion, count: 0 });\n      }\n    }\n  }\n\n  return pointsWithZero;\n}\n\nexport default VersionDownloadChart;\n"],"sourceRoot":""}